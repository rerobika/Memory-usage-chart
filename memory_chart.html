<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>
		JerryScript HTML (WebSocket) Debugger Client
	</title>
	<!-- Used third party libraries-->
	<link rel="stylesheet" type="text/css" href="https://raw.githack.com/c3js/c3/master/c3.css">
	<script src="https://raw.githack.com/c3js/c3/master/c3.min.js"></script>
	<script src="https://d3js.org/d3.v3.min.js"></script>

	<style>
		body {
			background-color: #feffd6;
			text-align: center;
		}

		.chartContainer
		{
			margin-left: 0 auto;
			text-align: center;
		}

		#chartContainer
		{
			width: 80%;
			display: inline-block;
			float: left;
		}
		#scrollBack, #scrollForward
		{
			float: left;
			height: 320px;
			width: 10%;
			background-color: transparent;
		}
	</style>
</head>
<body>
	<div class="container">
		<div id = "scrollBack">Back</div>
		<div id = "chartContainer">
			<div id="chart"></div>
		</div>
		<div id = "scrollForward">Forward</div>
		<button onclick="stopUpdateDataPoints()">Stop</button>
		<button onclick="startUpdateDataPoints()">Start</button>
	</div>
</body>
<script>
	var scrollB;
	var scrollF;
	var updateDataPoints;
	var maxDatapointNumber = 10;
	var minimumXIndex = 1;
	var dataUpdateInterval = 500;
	var scrollable = false;

	var time = ['x',];
	var allocated_bytes = ['allocated_bytes',];
	var object_bytes = ['object_bytes',];
	var property_bytes = ['property_bytes',];
	var string_bytes = ['string_bytes',];
	var byte_code_bytes = ['byte_code_bytes',];		

	document.getElementById("scrollBack").addEventListener("mouseenter", function() {scrollB = setInterval(scrollBack, dataUpdateInterval/4);});
	document.getElementById("scrollBack").addEventListener("mouseout", function() {clearInterval(scrollB);});
	document.getElementById("scrollForward").addEventListener("mouseenter", function() {scrollF = setInterval(scrollForward, dataUpdateInterval/4);});
	document.getElementById("scrollForward").addEventListener("mouseout", function() {clearInterval(scrollF);});
	document.getElementById("chartContainer").addEventListener("mousewheel", MouseWheelHandler);
	document.getElementById("chartContainer").addEventListener("DOMMouseScroll", MouseWheelHandler);
	
	var chart = c3.generate({
		data: {
			x: 'x',
			bindto: '#chart',
			transition: {
				duration: 0
			},
			columns: [
					time,
					allocated_bytes,
					object_bytes,
					property_bytes,
					string_bytes,
					byte_code_bytes
			],
			types: {
					allocated_bytes: 'area-spline',
					object_bytes: 'area-spline',
					property_bytes: 'area-spline',
					string_bytes: 'area-spline',
					byte_code_bytes: 'area-spline'
			},
			groups: [['allocated_bytes', 'object_bytes', 'property_bytes', 'string_bytes', 'byte_code_bytes']]
		},
		axis:{
			x: {
				type: 'timeseries',
				tick: {
					format: '%H:%M:%S:%L',
					culling: false,
					rotate: 60,
				}
			},
			y: {
				tick: {
				  format: function (d) { return d + " B"; }
				}
			  }
		}
			
	});

	function updateminimumXIndex()
	{
		minimumXIndex = time.length - (maxDatapointNumber + 1);
		return minimumXIndex;
	}

	function addNewDataPoints() {
		actualTime = new Date();
		time.push(actualTime);
		allocated_bytes.push(Math.floor(Math.random() * 50) + 100);
		object_bytes.push(Math.floor(Math.random() * 40) + 40);
		property_bytes.push(Math.floor(Math.random() * 30) + 30);
		string_bytes.push(Math.floor(Math.random() * 20) + 20);
		byte_code_bytes.push(Math.floor(Math.random() * 10) + 10);
		if(time.length <= maxDatapointNumber + 1)
		{
			chart.load({
			columns: [
					time,
					allocated_bytes,
					object_bytes,
					property_bytes,
					string_bytes,
					byte_code_bytes
			]
			});
		}
		else
		{
			minimumXIndex++;
			updateScrolledChart();
			
		}		
	}

	function stopUpdateDataPoints()
	{
		clearInterval(updateDataPoints);
		scrollable = true;
	}
	
	function startUpdateDataPoints()
	{
		stopUpdateDataPoints();
		updateDataPoints = setInterval(addNewDataPoints, dataUpdateInterval);
		scrollable = false;
	}
	
	function MouseWheelHandler(e) {

		if(e.wheelDelta > 0)
		{
			scrollForward();
		}
		else
		{
			scrollBack();
		}
	}
	
	function scrollBack()
	{
		if(time.length >= maxDatapointNumber + 1 && minimumXIndex > 1 && scrollable === true)
		{
			minimumXIndex --;
			updateScrolledChart();
		}		
	}

	function scrollForward()
	{
		if(time.length > maxDatapointNumber + minimumXIndex && scrollable === true)
		{
			minimumXIndex ++;
			updateScrolledChart();
		}
	}
	
	function updateScrolledChart()
	{
		chart.load({
			columns: [
					[time[0]].concat(time.slice(minimumXIndex, maxDatapointNumber + minimumXIndex)),
					[allocated_bytes[0]].concat(allocated_bytes.slice(minimumXIndex, maxDatapointNumber + minimumXIndex)),
					[object_bytes[0]].concat(object_bytes.slice( minimumXIndex, maxDatapointNumber + minimumXIndex)),
					[property_bytes[0]].concat(property_bytes.slice( minimumXIndex, maxDatapointNumber + minimumXIndex)),
					[string_bytes[0]].concat(string_bytes.slice( minimumXIndex, maxDatapointNumber + minimumXIndex)),
					[byte_code_bytes[0]].concat(byte_code_bytes.slice( minimumXIndex, maxDatapointNumber + minimumXIndex))
			]
		});
	}
</script>


</html>
